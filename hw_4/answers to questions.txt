1)  Почему использование тестовых заглушек может быть полезным при написании модульных тестов?
Ответ:
    Использование тестовых заглушек может быть полезным при написании модульных тестов по нескольким причинам:
        - Изоляция зависимостей: Тестовые заглушки позволяют изолировать модуль, который мы хотим протестировать, от его зависимостей. Это означает, что мы можем сосредоточиться только на одном модуле, не беспокоясь о правильной работе его зависимостей. Мы можем заменить реальные зависимости заглушками, которые имитируют ожидаемое поведение зависимости в контролируемой среде тестирования.

        - Контроль нежелательного поведения: С помощью тестовых заглушек мы можем имитировать нежелательное или сложное поведение зависимостей, которое может быть трудно воссоздать в реальной среде тестирования. Например, мы можем имитировать ошибку в базе данных или сетевом соединении, чтобы проверить, как наш модуль обрабатывает такие ситуации.

        - Ускорение выполнения тестов: Реальные зависимости, такие как база данных или внешние API, могут быть медленными или недоступными во время выполнения модульных тестов. Использование тестовых заглушек позволяет нам обойти эти зависимости и значительно ускорить выполнение тестов.

        - Повышение надежности тестов: Реальные зависимости могут вести себя неопределенно или изменяться со временем. Использование тестовых заглушек позволяет нам иметь полный контроль над поведением зависимостей во время тестирования, что делает наши тесты более надежными и предсказуемыми.

    В целом, использование тестовых заглушек помогает нам создавать модульные тесты, которые являются изолированными, предсказуемыми и легкими в поддержке, что способствует повышению качества кода и ускорению процесса разработки.

2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами?
Ответ:
    Для проверки, что метод был вызван с определенными аргументами, следует использовать тестовую заглушку, называемую "шпионом" (spy). Шпион - это объект, который записывает информацию о вызовах метода, включая переданные аргументы. Шпионы позволяют нам проверять, что метод был вызван с ожидаемыми аргументами, и даже проверять, сколько раз он был вызван и в каком порядке. Это полезно, когда мы хотим убедиться, что метод правильно взаимодействует с его зависимостями или выполняет определенные действия на основе переданных аргументов.

    Пример использования шпиона в тесте на Typescript с использованием Jasmine
    describe('MyClass', () => {
        it('should call doSomething method with expected arguments', () => {
        const spy = jasmine.createSpy('doSomethingSpy');
        const myObj = new MyClass(spy);

        myObj.someMethod();

        expect(spy).toHaveBeenCalledWith('expected argument');
        });
    });

    В этом примере мы создаем шпиона с помощью функции jasmine.createSpy(). Затем мы передаем этот шпион в объект MyClass и вызываем метод someMethod(). После этого мы используем expect и toHaveBeenCalledWith, чтобы проверить, что шпион был вызван с ожидаемым аргументом. Т.о., использование шпионов позволяет нам проверять, что методы вызываются с правильными аргументами, что является важной частью модульного тестирования.


3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода?
Ответ:
    Если просто нужно вернуть определенное значение или исключение в ответ на вызов метода, следует использовать тестовую заглушку, называемую "подставщиком" (stub). Подставщик - это объект, который заменяет реальную зависимость и предоставляет заранее определенные значения или исключения при вызове метода. Они позволяют нам контролировать поведение зависимости во время тестирования и обеспечивают предсказуемость результатов. Мы можем настроить подставщика таким образом, чтобы он возвращал ожидаемое значение или выбрасывал определенное исключение, что позволяет нам проверять, как наш код обрабатывает такие ситуации.

    Пример использования подставщика в тесте Typescript с использованием Jasmine:
    describe('MyClass', () => {
        it('should return expected value using a stub', () => {
            const stub = jasmine.createSpy('dependencyStub').and.returnValue('expected value');
            const myObj = new MyClass(stub);

            const result = myObj.someMethod();

            expect(result).toBe('expected value');
        });
    });

    В этом примере мы создаем подставщика с помощью функции jasmine.createSpy() и настраиваем его с помощью and.returnValue(), чтобы он возвращал ожидаемое значение при вызове. Затем мы передаем этот подставщик в объект MyClass и вызываем метод someMethod(). Далее мы используем expect и toBe, чтобы проверить, что результат метода соответствует ожидаемому значению. Т. о., использование подставщиков позволяет нам предоставлять заранее определенные значения или исключения во время тестирования, что помогает нам проверять, как наш код обрабатывает различные сценарии.

4) Какой тип тестовой заглушки вы бы использовали для имитации взаимодействия с внешним API или базой данных?
Ответ:
    Для имитации взаимодействия с внешним API или базой данных в unit-тестах можно использовать заглушки (mocks) или поддельные объекты (fakes).

    1. Заглушки (mocks): Заглушки создаются с использованием фреймворков для создания заглушек, таких как Mockito, Jest, Sinon и т. д. Они позволяют имитировать поведение внешнего API или базы данных, чтобы возвращать заранее определенные значения или проверять вызовы методов с определенными аргументами. Заглушки могут быть настроены для возвращения разных значений в зависимости от входных параметров или состояния тестируемого объекта.

    2. Поддельные объекты (fakes): Поддельные объекты создаются вручную и имитируют поведение внешнего API или базы данных. Они могут быть реализованы как простые классы, которые имитируют интерфейс или абстрактный класс, используемый взаимодействием с внешними системами. Поддельные объекты могут быть настроены для возвращения тестовых данных или проверки вызовов методов.

    Выбор между заглушками и поддельными объектами зависит от конкретного случая и предпочтений разработчика. Заглушки обычно предоставляют более гибкие возможности для настройки поведения, но требуют использования сторонних фреймворков. Поддельные объекты могут быть проще в использовании и настройке, но могут потребовать больше ручной работы.
